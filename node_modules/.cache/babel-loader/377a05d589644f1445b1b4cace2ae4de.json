{"ast":null,"code":"import _slicedToArray from \"/var/www/pathogen-intelligence.tgen.org/epitools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/var/www/pathogen-intelligence.tgen.org/epitools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"/var/www/pathogen-intelligence.tgen.org/epitools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { Tree, utils } from 'phylocanvas';\nvar getPixelRatio = utils.canvas.getPixelRatio;\nvar DEFAULTS = {\n  active: true,\n  pairwiseMatrix: {},\n  clusterActive: true,\n  clusterDraw: true,\n  clusterMatrix: [],\n  clusterMaxDistance: 20,\n  clusterDistance: 3,\n  clusterSamples: 3\n};\n\nfunction walkMatrix(tree, start, node, walked, distance, max) {\n  walked.push(node);\n\n  if (distance >= max) {\n    return;\n  }\n\n  if (node !== start && node.leaf === true) {\n    tree.pairwiseOps.pairwiseMatrix[start.id].push([node.id, distance]);\n  }\n\n  var _iterator = _createForOfIteratorHelper(node.children),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var child = _step.value;\n\n      if (!walked.includes(child)) {\n        var _newDistance = distance + child.branchLength;\n\n        _newDistance = parseFloat(_newDistance.toFixed(10));\n        walkMatrix(tree, start, child, walked, _newDistance, max);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (node.parent && !walked.includes(node.parent)) {\n    var newDistance = distance + node.branchLength;\n    newDistance = parseFloat(newDistance.toFixed(10));\n    walkMatrix(tree, start, node.parent, walked, newDistance, max);\n  }\n}\n\nfunction buildPairwiseMatrix() {\n  var _iterator2 = _createForOfIteratorHelper(this.leaves),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var leaf = _step2.value;\n      this.pairwiseOps.pairwiseMatrix[leaf.id] = [];\n      walkMatrix(this, leaf, leaf, [], 0, this.pairwiseOps.clusterMaxDistance);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n\nfunction buildClusterMatrix() {\n  this.pairwiseOps.clusterMatrix = [];\n\n  for (var leaf in this.pairwiseOps.pairwiseMatrix) {\n    var cluster = [leaf];\n\n    var _iterator3 = _createForOfIteratorHelper(this.pairwiseOps.pairwiseMatrix[leaf]),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var node = _step3.value;\n\n        if (node[1] <= this.pairwiseOps.clusterDistance) {\n          cluster.push(node[0]);\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    if (cluster.length >= this.pairwiseOps.clusterSamples) {\n      cluster.sort();\n      cluster = JSON.stringify(cluster);\n\n      if (!this.pairwiseOps.clusterMatrix.includes(cluster)) {\n        this.pairwiseOps.clusterMatrix.push(cluster);\n      }\n    }\n  }\n}\n\nfunction colorNode() {\n  var _iterator4 = _createForOfIteratorHelper(this.leaves),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var leaf = _step4.value;\n      leaf.setDisplay({\n        colour: this.branchColour\n      });\n      leaf.label = leaf.id;\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  var _iterator5 = _createForOfIteratorHelper(this.pairwiseOps.clusterMatrix),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var cluster = _step5.value;\n      cluster = JSON.parse(cluster);\n\n      var _iterator6 = _createForOfIteratorHelper(cluster),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var id = _step6.value;\n\n          var _iterator7 = _createForOfIteratorHelper(this.findLeaves(id)),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _leaf = _step7.value;\n              _leaf.label += \"+\";\n\n              _leaf.setDisplay({\n                colour: 'red'\n              });\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  this.draw();\n}\n\nexport default function plugin(decorate) {\n  decorate(this, 'createTree', function (delegate, args) {\n    var tree = delegate.apply(void 0, _toConsumableArray(args));\n\n    var _args = _slicedToArray(args, 2),\n        _args$ = _args[1],\n        config = _args$ === void 0 ? {} : _args$;\n\n    tree.pairwiseOps = Object.assign({}, DEFAULTS, config.pairwiseOps || {});\n    return tree;\n  });\n  decorate(Tree, 'load', function (delegate, args) {\n    delegate.apply(this, args);\n\n    if (this.pairwiseOps.active) {\n      buildPairwiseMatrix.apply(this);\n\n      if (this.pairwiseOps.clusterActive) {\n        this.pairwiseOps.clusterDraw = true;\n      }\n    }\n  });\n  decorate(Tree, 'draw', function (delegate, args) {\n    delegate.apply(this, args);\n\n    if (this.pairwiseOps.clusterActive) {\n      if (this.pairwiseOps.clusterDraw) {\n        this.pairwiseOps.clusterDraw = false;\n        buildClusterMatrix.apply(this);\n        colorNode.apply(this);\n      }\n    }\n  });\n}","map":{"version":3,"sources":["/var/www/pathogen-intelligence.tgen.org/epitools/my_modules/phylocanvas-plugin-pairwise-ops/index.js"],"names":["Tree","utils","getPixelRatio","canvas","DEFAULTS","active","pairwiseMatrix","clusterActive","clusterDraw","clusterMatrix","clusterMaxDistance","clusterDistance","clusterSamples","walkMatrix","tree","start","node","walked","distance","max","push","leaf","pairwiseOps","id","children","child","includes","newDistance","branchLength","parseFloat","toFixed","parent","buildPairwiseMatrix","leaves","buildClusterMatrix","cluster","length","sort","JSON","stringify","colorNode","setDisplay","colour","branchColour","label","parse","findLeaves","draw","plugin","decorate","delegate","args","config","Object","assign","apply"],"mappings":"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","sourcesContent":["import { Tree, utils } from 'phylocanvas';\n\nconst { getPixelRatio } = utils.canvas;\n\nconst DEFAULTS = {\n  active: true,\n  pairwiseMatrix: {},\n  clusterActive: true,\n  clusterDraw: true,\n  clusterMatrix: [],\n  clusterMaxDistance: 20,\n  clusterDistance: 3,\n  clusterSamples: 3,\n};\n\nfunction walkMatrix(tree, start, node, walked, distance, max) {\n  walked.push(node)\n\n  if (distance >= max) {\n    return\n  }\n  if (node !== start && node.leaf === true) {\n    tree.pairwiseOps.pairwiseMatrix[start.id].push([node.id, distance])\n  }\n  for (let child of node.children) {\n    if (! walked.includes(child)) {\n      let newDistance = distance + child.branchLength\n      newDistance = parseFloat(newDistance.toFixed(10))\n      walkMatrix(tree, start, child, walked, newDistance, max)\n    }\n  }\n  if (node.parent && ! walked.includes(node.parent)) {\n    let newDistance = distance + node.branchLength\n    newDistance = parseFloat(newDistance.toFixed(10))\n    walkMatrix(tree, start, node.parent, walked, newDistance, max)\n  }\n}\n\nfunction buildPairwiseMatrix() {\n  for (let leaf of this.leaves) {\n    this.pairwiseOps.pairwiseMatrix[leaf.id] = []\n    walkMatrix(this, leaf, leaf, [], 0, this.pairwiseOps.clusterMaxDistance)\n  }\n}\n\nfunction buildClusterMatrix() {\n  this.pairwiseOps.clusterMatrix = []\n  for (let leaf in this.pairwiseOps.pairwiseMatrix) {\n    let cluster = [leaf]\n    for (let node of this.pairwiseOps.pairwiseMatrix[leaf]) {\n      if (node[1] <= this.pairwiseOps.clusterDistance) {\n        cluster.push(node[0])\n      }\n    }\n    if (cluster.length >= this.pairwiseOps.clusterSamples) {\n      cluster.sort()\n      cluster = JSON.stringify(cluster)\n      if (! this.pairwiseOps.clusterMatrix.includes(cluster)) {\n        this.pairwiseOps.clusterMatrix.push(cluster)\n      }\n    }\n  }\n}\n\nfunction colorNode() {\n  for (let leaf of this.leaves) {\n    leaf.setDisplay({\n      colour: this.branchColour,\n    })\n    leaf.label = leaf.id\n  }\n  for (let cluster of this.pairwiseOps.clusterMatrix) {\n    cluster = JSON.parse(cluster)\n    for (let id of cluster) {\n      \n      for (let leaf of this.findLeaves(id)) {\n        leaf.label += \"+\"\n        leaf.setDisplay({\n          colour: 'red',\n        })\n      }\n    }\n  }\n  this.draw()\n}\n\nexport default function plugin(decorate) {\n  decorate(this, 'createTree', (delegate, args) => {\n    const tree = delegate(...args);\n    const [ , config = {} ] = args;\n    tree.pairwiseOps = Object.assign({}, DEFAULTS, config.pairwiseOps || {});\n    return tree;\n  });\n  decorate(Tree, 'load', function (delegate, args) {\n    delegate.apply(this, args);\n    if (this.pairwiseOps.active) {\n      buildPairwiseMatrix.apply(this);\n      if (this.pairwiseOps.clusterActive) {\n        this.pairwiseOps.clusterDraw = true;\n      }\n    }   \n  });\n  decorate(Tree, 'draw', function (delegate, args) {\n    delegate.apply(this, args);\n    if (this.pairwiseOps.clusterActive) {\n      if (this.pairwiseOps.clusterDraw) {\n        this.pairwiseOps.clusterDraw = false;\n        buildClusterMatrix.apply(this);\n        colorNode.apply(this)\n      }\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}