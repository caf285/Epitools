{"ast":null,"code":"import _slicedToArray from \"/var/www/pathogen-intelligence.tgen.org/epitools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/var/www/pathogen-intelligence.tgen.org/epitools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"/var/www/pathogen-intelligence.tgen.org/epitools/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { Tree, utils } from 'phylocanvas';\nvar getPixelRatio = utils.canvas.getPixelRatio;\nvar DEFAULTS = {\n  active: true,\n  pairwiseMatrix: {},\n  clusterActive: true,\n  clusterDraw: true,\n  clusterMatrix: [],\n  clusterMaxDistance: 20,\n  clusterDistance: 3,\n  clusterSamples: 3\n}; // OLDER cluster matrix code\n\n/*\nfunction walkMatrix(tree, start, node, walked, distance, max) {\n  walked.push(node)\n\n  if (distance >= max) {\n    return\n  }\n  if (node !== start && node.leaf === true) {\n    tree.pairwiseOps.pairwiseMatrix[start.id].push([node.id, distance])\n  }\n  for (let child of node.children) {\n    if (! walked.includes(child)) {\n      let newDistance = distance + child.branchLength\n      newDistance = parseFloat(newDistance.toFixed(10))\n      walkMatrix(tree, start, child, walked, newDistance, max)\n    }\n  }\n  if (node.parent && ! walked.includes(node.parent)) {\n    let newDistance = distance + node.branchLength\n    newDistance = parseFloat(newDistance.toFixed(10))\n    walkMatrix(tree, start, node.parent, walked, newDistance, max)\n  }\n}\n\nfunction buildPairwiseMatrix() {\n  for (let leaf of this.leaves) {\n    this.pairwiseOps.pairwiseMatrix[leaf.id] = []\n    walkMatrix(this, leaf, leaf, [], 0, this.pairwiseOps.clusterMaxDistance)\n  }\n  console.log(this.pairwiseOps.pairwiseMatrix)\n}\n*/\n\n/*\nfunction buildClusterMatrix() {\n  this.pairwiseOps.clusterMatrix = []\n  for (let leaf in this.pairwiseOps.pairwiseMatrix) {\n    let cluster = [leaf]\n    for (let node of this.pairwiseOps.pairwiseMatrix[leaf]) {\n      if (node[1] <= this.pairwiseOps.clusterDistance) {\n        cluster.push(node[0])\n      }\n    }\n    if (cluster.length >= this.pairwiseOps.clusterSamples) {\n      cluster.sort()\n      cluster = JSON.stringify(cluster)\n      if (! this.pairwiseOps.clusterMatrix.includes(cluster)) {\n        this.pairwiseOps.clusterMatrix.push(cluster)\n      }\n    }\n  }\n}\n*/\n\nfunction walkMatrix(tree, node, path, distance) {\n  var newDistance = Array.from(distance);\n  var newPath = Array.from(path);\n  newDistance.push(node.branchLength);\n\n  if (node.leaf === false) {\n    newPath.push(node.id);\n    tree.pairwiseOps.pairwiseMatrix.internalNodes[node.id] = [];\n\n    var _iterator = _createForOfIteratorHelper(node.children),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var child = _step.value;\n        walkMatrix(tree, child, newPath, newDistance);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else {\n    tree.pairwiseOps.pairwiseMatrix.leaves[node.id] = {};\n    newDistance.push(newDistance.shift());\n\n    for (var i in newPath) {\n      var nodeLength = newDistance.slice(i).reduce(function (previousValue, currentValue) {\n        return previousValue + currentValue;\n      });\n\n      var _iterator2 = _createForOfIteratorHelper(tree.pairwiseOps.pairwiseMatrix.internalNodes[newPath[i]]),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var leaf = _step2.value;\n\n          if (!Object.keys(tree.pairwiseOps.pairwiseMatrix.leaves[node.id]).includes(leaf[0])) {\n            tree.pairwiseOps.pairwiseMatrix.leaves[node.id][leaf[0]] = leaf[1] + nodeLength;\n          } else if (tree.pairwiseOps.pairwiseMatrix.leaves[node.id][leaf[0]] > leaf[1] + nodeLength) {\n            tree.pairwiseOps.pairwiseMatrix.leaves[node.id][leaf[0]] = leaf[1] + nodeLength;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      tree.pairwiseOps.pairwiseMatrix.internalNodes[newPath[i]].push([node.id, nodeLength]);\n    }\n  }\n}\n\nfunction buildPairwiseMatrix() {\n  this.pairwiseOps.pairwiseMatrix = {\n    \"internalNodes\": {},\n    \"leaves\": {}\n  };\n  walkMatrix(this, this.root, [], []);\n\n  for (var node in this.pairwiseOps.pairwiseMatrix.leaves) {\n    for (var leaf in this.pairwiseOps.pairwiseMatrix.leaves[node]) {\n      this.pairwiseOps.pairwiseMatrix.leaves[leaf][node] = this.pairwiseOps.pairwiseMatrix.leaves[node][leaf];\n    }\n  }\n\n  console.log(this.pairwiseOps.pairwiseMatrix.leaves);\n}\n\nfunction buildClusterMatrix() {\n  this.pairwiseOps.clusterMatrix = [];\n\n  for (var leaf in this.pairwiseOps.pairwiseMatrix.leaves) {\n    var cluster = [leaf];\n\n    for (var pair in this.pairwiseOps.pairwiseMatrix.leaves[leaf]) {\n      if (this.pairwiseOps.pairwiseMatrix.leaves[leaf][pair] <= this.pairwiseOps.clusterDistance) {\n        cluster.push(pair);\n      }\n    }\n\n    if (cluster.length >= this.pairwiseOps.clusterSamples) {\n      cluster.sort();\n      cluster = JSON.stringify(cluster);\n\n      if (!this.pairwiseOps.clusterMatrix.includes(cluster)) {\n        this.pairwiseOps.clusterMatrix.push(cluster);\n      }\n    }\n  }\n}\n\nfunction colorNode() {\n  var _iterator3 = _createForOfIteratorHelper(this.leaves),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var leaf = _step3.value;\n      leaf.setDisplay({\n        colour: this.branchColour\n      });\n      leaf.label = leaf.id;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  var _iterator4 = _createForOfIteratorHelper(this.pairwiseOps.clusterMatrix),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var cluster = _step4.value;\n      cluster = JSON.parse(cluster);\n\n      var _iterator5 = _createForOfIteratorHelper(cluster),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var id = _step5.value;\n\n          var _iterator6 = _createForOfIteratorHelper(this.findLeaves(id)),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _leaf = _step6.value;\n              _leaf.label += \"+\";\n\n              _leaf.setDisplay({\n                colour: 'red'\n              });\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  this.draw();\n}\n\nfunction drawClusterInfo() {\n  var label = \"Cluster Size: \" + String(this.pairwiseOps.clusterSamples) + \"; Cluster Distance: \" + String(this.pairwiseOps.clusterDistance);\n  var ctx = this.canvas;\n  var pixelRatio = getPixelRatio(ctx);\n  ctx.save();\n  ctx.font = \"\".concat(30 * pixelRatio / 2, \"px Arial\");\n  ctx.fillText(label, ctx.canvas.width - ctx.measureText(label).width - 10, ctx.canvas.height - 10);\n  ctx.restore();\n}\n\nexport default function plugin(decorate) {\n  decorate(this, 'createTree', function (delegate, args) {\n    var tree = delegate.apply(void 0, _toConsumableArray(args));\n\n    var _args = _slicedToArray(args, 2),\n        _args$ = _args[1],\n        config = _args$ === void 0 ? {} : _args$;\n\n    tree.pairwiseOps = Object.assign({}, DEFAULTS, config.pairwiseOps || {});\n    return tree;\n  });\n  decorate(Tree, 'load', function (delegate, args) {\n    delegate.apply(this, args);\n\n    if (this.pairwiseOps.active) {\n      buildPairwiseMatrix.apply(this);\n\n      if (this.pairwiseOps.clusterActive) {\n        this.pairwiseOps.clusterDraw = true;\n      }\n    }\n  });\n  decorate(Tree, 'draw', function (delegate, args) {\n    delegate.apply(this, args);\n\n    if (this.pairwiseOps.clusterActive) {\n      if (this.pairwiseOps.clusterDraw) {\n        this.pairwiseOps.clusterDraw = false;\n        buildClusterMatrix.apply(this);\n        colorNode.apply(this);\n      }\n\n      drawClusterInfo.apply(this);\n    }\n  });\n}","map":{"version":3,"sources":["/var/www/pathogen-intelligence.tgen.org/epitools/my_modules/phylocanvas-plugin-pairwise-ops/index.js"],"names":["Tree","utils","getPixelRatio","canvas","DEFAULTS","active","pairwiseMatrix","clusterActive","clusterDraw","clusterMatrix","clusterMaxDistance","clusterDistance","clusterSamples","walkMatrix","tree","node","path","distance","newDistance","Array","from","newPath","push","branchLength","leaf","id","pairwiseOps","internalNodes","children","child","leaves","shift","i","nodeLength","slice","reduce","previousValue","currentValue","Object","keys","includes","buildPairwiseMatrix","root","console","log","buildClusterMatrix","cluster","pair","length","sort","JSON","stringify","colorNode","setDisplay","colour","branchColour","label","parse","findLeaves","draw","drawClusterInfo","String","ctx","pixelRatio","save","font","fillText","width","measureText","height","restore","plugin","decorate","delegate","args","config","assign","apply"],"mappings":"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","sourcesContent":["import { Tree, utils } from 'phylocanvas';\n\nconst { getPixelRatio } = utils.canvas;\n\nconst DEFAULTS = {\n  active: true,\n  pairwiseMatrix: {},\n  clusterActive: true,\n  clusterDraw: true,\n  clusterMatrix: [],\n  clusterMaxDistance: 20,\n  clusterDistance: 3,\n  clusterSamples: 3,\n};\n\n// OLDER cluster matrix code\n/*\nfunction walkMatrix(tree, start, node, walked, distance, max) {\n  walked.push(node)\n\n  if (distance >= max) {\n    return\n  }\n  if (node !== start && node.leaf === true) {\n    tree.pairwiseOps.pairwiseMatrix[start.id].push([node.id, distance])\n  }\n  for (let child of node.children) {\n    if (! walked.includes(child)) {\n      let newDistance = distance + child.branchLength\n      newDistance = parseFloat(newDistance.toFixed(10))\n      walkMatrix(tree, start, child, walked, newDistance, max)\n    }\n  }\n  if (node.parent && ! walked.includes(node.parent)) {\n    let newDistance = distance + node.branchLength\n    newDistance = parseFloat(newDistance.toFixed(10))\n    walkMatrix(tree, start, node.parent, walked, newDistance, max)\n  }\n}\n\nfunction buildPairwiseMatrix() {\n  for (let leaf of this.leaves) {\n    this.pairwiseOps.pairwiseMatrix[leaf.id] = []\n    walkMatrix(this, leaf, leaf, [], 0, this.pairwiseOps.clusterMaxDistance)\n  }\n  console.log(this.pairwiseOps.pairwiseMatrix)\n}\n*/\n\n/*\nfunction buildClusterMatrix() {\n  this.pairwiseOps.clusterMatrix = []\n  for (let leaf in this.pairwiseOps.pairwiseMatrix) {\n    let cluster = [leaf]\n    for (let node of this.pairwiseOps.pairwiseMatrix[leaf]) {\n      if (node[1] <= this.pairwiseOps.clusterDistance) {\n        cluster.push(node[0])\n      }\n    }\n    if (cluster.length >= this.pairwiseOps.clusterSamples) {\n      cluster.sort()\n      cluster = JSON.stringify(cluster)\n      if (! this.pairwiseOps.clusterMatrix.includes(cluster)) {\n        this.pairwiseOps.clusterMatrix.push(cluster)\n      }\n    }\n  }\n}\n*/\n\nfunction walkMatrix(tree, node, path, distance) {\n  let newDistance = Array.from(distance)\n  let newPath = Array.from(path)\n  newDistance.push(node.branchLength)\n  if (node.leaf === false) {\n    newPath.push(node.id)\n    tree.pairwiseOps.pairwiseMatrix.internalNodes[node.id] = []\n    for (let child of node.children) {\n      walkMatrix(tree, child, newPath, newDistance)\n    }\n  } else {\n    tree.pairwiseOps.pairwiseMatrix.leaves[node.id] = {}\n    newDistance.push(newDistance.shift())\n    for (let i in newPath) {\n      let nodeLength = newDistance.slice(i).reduce((previousValue, currentValue) => previousValue + currentValue)\n      for (let leaf of tree.pairwiseOps.pairwiseMatrix.internalNodes[newPath[i]]) {\n        if (! Object.keys(tree.pairwiseOps.pairwiseMatrix.leaves[node.id]).includes(leaf[0])) {\n          tree.pairwiseOps.pairwiseMatrix.leaves[node.id][leaf[0]] = leaf[1] + nodeLength\n        } else if (tree.pairwiseOps.pairwiseMatrix.leaves[node.id][leaf[0]] > leaf[1] + nodeLength) {\n          tree.pairwiseOps.pairwiseMatrix.leaves[node.id][leaf[0]] = leaf[1] + nodeLength\n        }\n      }\n      tree.pairwiseOps.pairwiseMatrix.internalNodes[newPath[i]].push([node.id, nodeLength])\n    }\n  }  \n}\n\nfunction buildPairwiseMatrix() {\n  this.pairwiseOps.pairwiseMatrix = {\"internalNodes\": {}, \"leaves\": {}}\n  walkMatrix(this, this.root, [], [])\n  for (let node in this.pairwiseOps.pairwiseMatrix.leaves) {\n    for (let leaf in this.pairwiseOps.pairwiseMatrix.leaves[node]) {\n      this.pairwiseOps.pairwiseMatrix.leaves[leaf][node] = this.pairwiseOps.pairwiseMatrix.leaves[node][leaf]\n    }\n  }\n  console.log(this.pairwiseOps.pairwiseMatrix.leaves)\n}\n\nfunction buildClusterMatrix() {\n  this.pairwiseOps.clusterMatrix = []\n  for (let leaf in this.pairwiseOps.pairwiseMatrix.leaves) {\n    let cluster = [leaf]\n    for (let pair in this.pairwiseOps.pairwiseMatrix.leaves[leaf]) {\n      if (this.pairwiseOps.pairwiseMatrix.leaves[leaf][pair] <= this.pairwiseOps.clusterDistance) {\n        cluster.push(pair)\n      }\n    }\n    if (cluster.length >= this.pairwiseOps.clusterSamples) {\n      cluster.sort()\n      cluster = JSON.stringify(cluster)\n      if (! this.pairwiseOps.clusterMatrix.includes(cluster)) {\n        this.pairwiseOps.clusterMatrix.push(cluster)\n      }\n    }\n  }\n}\n\nfunction colorNode() {\n  for (let leaf of this.leaves) {\n    leaf.setDisplay({\n      colour: this.branchColour,\n    })\n    leaf.label = leaf.id\n  }\n  for (let cluster of this.pairwiseOps.clusterMatrix) {\n    cluster = JSON.parse(cluster)\n    for (let id of cluster) {\n      \n      for (let leaf of this.findLeaves(id)) {\n        leaf.label += \"+\"\n        leaf.setDisplay({\n          colour: 'red',\n        })\n      }\n    }\n  }\n  this.draw()\n}\n\nfunction drawClusterInfo() {\n  let label = \"Cluster Size: \" + String(this.pairwiseOps.clusterSamples) + \"; Cluster Distance: \" + String(this.pairwiseOps.clusterDistance)\n  let ctx = this.canvas\n  let pixelRatio = getPixelRatio(ctx)\n  ctx.save()\n  ctx.font = `${30 * pixelRatio / 2}px Arial`;\n  ctx.fillText(label, ctx.canvas.width - ctx.measureText(label).width - 10, ctx.canvas.height - 10)\n  ctx.restore()\n}\n\nexport default function plugin(decorate) {\n  decorate(this, 'createTree', (delegate, args) => {\n    const tree = delegate(...args);\n    const [ , config = {} ] = args;\n    tree.pairwiseOps = Object.assign({}, DEFAULTS, config.pairwiseOps || {});\n    return tree;\n  });\n  decorate(Tree, 'load', function (delegate, args) {\n    delegate.apply(this, args);\n    if (this.pairwiseOps.active) {\n      buildPairwiseMatrix.apply(this);\n      if (this.pairwiseOps.clusterActive) {\n        this.pairwiseOps.clusterDraw = true;\n      }\n    }   \n  });\n  decorate(Tree, 'draw', function (delegate, args) {\n    delegate.apply(this, args);\n    if (this.pairwiseOps.clusterActive) {\n      if (this.pairwiseOps.clusterDraw) {\n        this.pairwiseOps.clusterDraw = false;\n        buildClusterMatrix.apply(this);\n        colorNode.apply(this);\n      }\n      drawClusterInfo.apply(this);\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}