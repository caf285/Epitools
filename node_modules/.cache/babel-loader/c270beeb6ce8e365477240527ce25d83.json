{"ast":null,"code":"import { Tree, utils } from 'phylocanvas';\nconst {\n  getPixelRatio\n} = utils.canvas;\nconst DEFAULTS = {\n  active: true,\n  pairwiseMatrix: {},\n  clusterActive: true,\n  clusterDraw: true,\n  clusterMatrix: [],\n  clusterMaxDistance: 20,\n  clusterDistance: 3,\n  clusterSamples: 3\n};\n/*\nfunction walkMatrix(tree, start, node, walked, distance, max) {\n  walked.push(node)\n\n  if (distance >= max) {\n    return\n  }\n  if (node !== start && node.leaf === true) {\n    tree.pairwiseOps.pairwiseMatrix[start.id].push([node.id, distance])\n  }\n  for (let child of node.children) {\n    if (! walked.includes(child)) {\n      let newDistance = distance + child.branchLength\n      newDistance = parseFloat(newDistance.toFixed(10))\n      walkMatrix(tree, start, child, walked, newDistance, max)\n    }\n  }\n  if (node.parent && ! walked.includes(node.parent)) {\n    let newDistance = distance + node.branchLength\n    newDistance = parseFloat(newDistance.toFixed(10))\n    walkMatrix(tree, start, node.parent, walked, newDistance, max)\n  }\n}\n\nfunction buildPairwiseMatrix() {\n  for (let leaf of this.leaves) {\n    this.pairwiseOps.pairwiseMatrix[leaf.id] = []\n    walkMatrix(this, leaf, leaf, [], 0, this.pairwiseOps.clusterMaxDistance)\n  }\n  console.log(this.pairwiseOps.pairwiseMatrix)\n}\n*/\n\nfunction walkMatrix(tree, node, path, distance) {\n  let newDistance = Array.from(distance);\n  let newPath = Array.from(path);\n\n  if (node.leaf === true) {\n    tree.pairwiseOps.pairwiseMatrix.leaves[node.id] = {};\n  }\n\n  if (node.parent !== null) {\n    newDistance.push(node.branchLength);\n  }\n\n  if (node.leaf === false) {\n    tree.pairwiseOps.pairwiseMatrix.internalNodes[node.id] = [];\n    newPath.push(node.id);\n\n    for (let child of node.children) {\n      walkMatrix(tree, child, newPath, newDistance);\n    }\n  } else {\n    for (let i in newPath) {\n      tree.pairwiseOps.pairwiseMatrix.internalNodes[newPath[i]].push([node.id, newDistance.slice(i).reduce((previousValue, currentValue) => previousValue + currentValue)]);\n    }\n  }\n}\n\nfunction buildPairwiseMatrix() {\n  this.pairwiseOps.pairwiseMatrix = {\n    \"internalNodes\": {},\n    \"leaves\": {}\n  };\n  walkMatrix(this, this.root, [], []);\n  console.log(\"internal nodes\", this.pairwiseOps.pairwiseMatrix.internalNodes);\n\n  for (let node in this.pairwiseOps.pairwiseMatrix.internalNodes) {\n    node = this.pairwiseOps.pairwiseMatrix.internalNodes[node]; //console.log(node)\n\n    for (let leaf1 in node) {\n      for (let leaf2 in node.slice(leaf1 + 1)) {\n        if (!Object.keys(this.pairwiseOps.pairwiseMatrix.leaves[node[leaf1][0]]).includes(node[leaf2][0])) {\n          this.pairwiseOps.pairwiseMatrix.leaves[node[leaf1][0]][node[leaf2][0]] = node[leaf1][1] + node[leaf2][1];\n          this.pairwiseOps.pairwiseMatrix.leaves[node[leaf2][0]][node[leaf1][0]] = node[leaf1][1] + node[leaf2][1];\n        } else if (this.pairwiseOps.pairwiseMatrix.leaves[node[leaf1][0]][node[leaf2][0]] > node[leaf1][1] + node[leaf2][1]) {\n          this.pairwiseOps.pairwiseMatrix.leaves[node[leaf1][0]][node[leaf2][0]] = node[leaf1][1] + node[leaf2][1];\n          this.pairwiseOps.pairwiseMatrix.leaves[node[leaf2][0]][node[leaf1][0]] = node[leaf1][1] + node[leaf2][1];\n        }\n      }\n    }\n  }\n\n  console.log(this.pairwiseOps.pairwiseMatrix);\n  console.log(this);\n}\n\nfunction buildClusterMatrix() {\n  this.pairwiseOps.clusterMatrix = [];\n\n  for (let leaf in this.pairwiseOps.pairwiseMatrix) {\n    let cluster = [leaf];\n\n    for (let node of this.pairwiseOps.pairwiseMatrix[leaf]) {\n      if (node[1] <= this.pairwiseOps.clusterDistance) {\n        cluster.push(node[0]);\n      }\n    }\n\n    if (cluster.length >= this.pairwiseOps.clusterSamples) {\n      cluster.sort();\n      cluster = JSON.stringify(cluster);\n\n      if (!this.pairwiseOps.clusterMatrix.includes(cluster)) {\n        this.pairwiseOps.clusterMatrix.push(cluster);\n      }\n    }\n  }\n}\n\nfunction colorNode() {\n  for (let leaf of this.leaves) {\n    leaf.setDisplay({\n      colour: this.branchColour\n    });\n    leaf.label = leaf.id;\n  }\n\n  for (let cluster of this.pairwiseOps.clusterMatrix) {\n    cluster = JSON.parse(cluster);\n\n    for (let id of cluster) {\n      for (let leaf of this.findLeaves(id)) {\n        leaf.label += \"+\";\n        leaf.setDisplay({\n          colour: 'red'\n        });\n      }\n    }\n  }\n\n  this.draw();\n}\n\nexport default function plugin(decorate) {\n  decorate(this, 'createTree', (delegate, args) => {\n    const tree = delegate(...args);\n    const [, config = {}] = args;\n    tree.pairwiseOps = Object.assign({}, DEFAULTS, config.pairwiseOps || {});\n    return tree;\n  });\n  decorate(Tree, 'load', function (delegate, args) {\n    delegate.apply(this, args);\n\n    if (this.pairwiseOps.active) {\n      buildPairwiseMatrix.apply(this);\n\n      if (this.pairwiseOps.clusterActive) {\n        this.pairwiseOps.clusterDraw = true;\n      }\n    }\n  });\n  decorate(Tree, 'draw', function (delegate, args) {\n    delegate.apply(this, args);\n\n    if (this.pairwiseOps.clusterActive) {\n      if (this.pairwiseOps.clusterDraw) {\n        this.pairwiseOps.clusterDraw = false; //buildClusterMatrix.apply(this);\n        //colorNode.apply(this)\n      }\n    }\n  });\n}","map":{"version":3,"sources":["/var/www/pathogen-intelligence.tgen.org/epitools/my_modules/phylocanvas-plugin-pairwise-ops/index.js"],"names":["Tree","utils","getPixelRatio","canvas","DEFAULTS","active","pairwiseMatrix","clusterActive","clusterDraw","clusterMatrix","clusterMaxDistance","clusterDistance","clusterSamples","walkMatrix","tree","node","path","distance","newDistance","Array","from","newPath","leaf","pairwiseOps","leaves","id","parent","push","branchLength","internalNodes","child","children","i","slice","reduce","previousValue","currentValue","buildPairwiseMatrix","root","console","log","leaf1","leaf2","Object","keys","includes","buildClusterMatrix","cluster","length","sort","JSON","stringify","colorNode","setDisplay","colour","branchColour","label","parse","findLeaves","draw","plugin","decorate","delegate","args","config","assign","apply"],"mappings":"AAAA,SAASA,IAAT,EAAeC,KAAf,QAA4B,aAA5B;AAEA,MAAM;AAAEC,EAAAA;AAAF,IAAoBD,KAAK,CAACE,MAAhC;AAEA,MAAMC,QAAQ,GAAG;AACfC,EAAAA,MAAM,EAAE,IADO;AAEfC,EAAAA,cAAc,EAAE,EAFD;AAGfC,EAAAA,aAAa,EAAE,IAHA;AAIfC,EAAAA,WAAW,EAAE,IAJE;AAKfC,EAAAA,aAAa,EAAE,EALA;AAMfC,EAAAA,kBAAkB,EAAE,EANL;AAOfC,EAAAA,eAAe,EAAE,CAPF;AAQfC,EAAAA,cAAc,EAAE;AARD,CAAjB;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,UAAT,CAAoBC,IAApB,EAA0BC,IAA1B,EAAgCC,IAAhC,EAAsCC,QAAtC,EAAgD;AAC9C,MAAIC,WAAW,GAAGC,KAAK,CAACC,IAAN,CAAWH,QAAX,CAAlB;AACA,MAAII,OAAO,GAAGF,KAAK,CAACC,IAAN,CAAWJ,IAAX,CAAd;;AACA,MAAID,IAAI,CAACO,IAAL,KAAc,IAAlB,EAAwB;AACtBR,IAAAA,IAAI,CAACS,WAAL,CAAiBjB,cAAjB,CAAgCkB,MAAhC,CAAuCT,IAAI,CAACU,EAA5C,IAAkD,EAAlD;AACD;;AACD,MAAIV,IAAI,CAACW,MAAL,KAAgB,IAApB,EAA0B;AACxBR,IAAAA,WAAW,CAACS,IAAZ,CAAiBZ,IAAI,CAACa,YAAtB;AACD;;AACD,MAAIb,IAAI,CAACO,IAAL,KAAc,KAAlB,EAAyB;AACvBR,IAAAA,IAAI,CAACS,WAAL,CAAiBjB,cAAjB,CAAgCuB,aAAhC,CAA8Cd,IAAI,CAACU,EAAnD,IAAyD,EAAzD;AACAJ,IAAAA,OAAO,CAACM,IAAR,CAAaZ,IAAI,CAACU,EAAlB;;AACA,SAAK,IAAIK,KAAT,IAAkBf,IAAI,CAACgB,QAAvB,EAAiC;AAC/BlB,MAAAA,UAAU,CAACC,IAAD,EAAOgB,KAAP,EAAcT,OAAd,EAAuBH,WAAvB,CAAV;AACD;AACF,GAND,MAMO;AACL,SAAK,IAAIc,CAAT,IAAcX,OAAd,EAAuB;AACrBP,MAAAA,IAAI,CAACS,WAAL,CAAiBjB,cAAjB,CAAgCuB,aAAhC,CAA8CR,OAAO,CAACW,CAAD,CAArD,EAA0DL,IAA1D,CAA+D,CAACZ,IAAI,CAACU,EAAN,EAAUP,WAAW,CAACe,KAAZ,CAAkBD,CAAlB,EAAqBE,MAArB,CAA4B,CAACC,aAAD,EAAgBC,YAAhB,KAAiCD,aAAa,GAAGC,YAA7E,CAAV,CAA/D;AACD;AACF;AACF;;AAED,SAASC,mBAAT,GAA+B;AAC7B,OAAKd,WAAL,CAAiBjB,cAAjB,GAAkC;AAAC,qBAAiB,EAAlB;AAAsB,cAAU;AAAhC,GAAlC;AACAO,EAAAA,UAAU,CAAC,IAAD,EAAO,KAAKyB,IAAZ,EAAkB,EAAlB,EAAsB,EAAtB,CAAV;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ,EAA8B,KAAKjB,WAAL,CAAiBjB,cAAjB,CAAgCuB,aAA9D;;AACA,OAAK,IAAId,IAAT,IAAiB,KAAKQ,WAAL,CAAiBjB,cAAjB,CAAgCuB,aAAjD,EAAgE;AAC9Dd,IAAAA,IAAI,GAAG,KAAKQ,WAAL,CAAiBjB,cAAjB,CAAgCuB,aAAhC,CAA8Cd,IAA9C,CAAP,CAD8D,CAE9D;;AACA,SAAK,IAAI0B,KAAT,IAAkB1B,IAAlB,EAAwB;AACtB,WAAK,IAAI2B,KAAT,IAAkB3B,IAAI,CAACkB,KAAL,CAAWQ,KAAK,GAAG,CAAnB,CAAlB,EAAyC;AACvC,YAAI,CAAEE,MAAM,CAACC,IAAP,CAAY,KAAKrB,WAAL,CAAiBjB,cAAjB,CAAgCkB,MAAhC,CAAuCT,IAAI,CAAC0B,KAAD,CAAJ,CAAY,CAAZ,CAAvC,CAAZ,EAAoEI,QAApE,CAA6E9B,IAAI,CAAC2B,KAAD,CAAJ,CAAY,CAAZ,CAA7E,CAAN,EAAoG;AAClG,eAAKnB,WAAL,CAAiBjB,cAAjB,CAAgCkB,MAAhC,CAAuCT,IAAI,CAAC0B,KAAD,CAAJ,CAAY,CAAZ,CAAvC,EAAuD1B,IAAI,CAAC2B,KAAD,CAAJ,CAAY,CAAZ,CAAvD,IAAyE3B,IAAI,CAAC0B,KAAD,CAAJ,CAAY,CAAZ,IAAiB1B,IAAI,CAAC2B,KAAD,CAAJ,CAAY,CAAZ,CAA1F;AACA,eAAKnB,WAAL,CAAiBjB,cAAjB,CAAgCkB,MAAhC,CAAuCT,IAAI,CAAC2B,KAAD,CAAJ,CAAY,CAAZ,CAAvC,EAAuD3B,IAAI,CAAC0B,KAAD,CAAJ,CAAY,CAAZ,CAAvD,IAAyE1B,IAAI,CAAC0B,KAAD,CAAJ,CAAY,CAAZ,IAAiB1B,IAAI,CAAC2B,KAAD,CAAJ,CAAY,CAAZ,CAA1F;AACD,SAHD,MAGO,IAAI,KAAKnB,WAAL,CAAiBjB,cAAjB,CAAgCkB,MAAhC,CAAuCT,IAAI,CAAC0B,KAAD,CAAJ,CAAY,CAAZ,CAAvC,EAAuD1B,IAAI,CAAC2B,KAAD,CAAJ,CAAY,CAAZ,CAAvD,IAAyE3B,IAAI,CAAC0B,KAAD,CAAJ,CAAY,CAAZ,IAAiB1B,IAAI,CAAC2B,KAAD,CAAJ,CAAY,CAAZ,CAA9F,EAA8G;AACnH,eAAKnB,WAAL,CAAiBjB,cAAjB,CAAgCkB,MAAhC,CAAuCT,IAAI,CAAC0B,KAAD,CAAJ,CAAY,CAAZ,CAAvC,EAAuD1B,IAAI,CAAC2B,KAAD,CAAJ,CAAY,CAAZ,CAAvD,IAAyE3B,IAAI,CAAC0B,KAAD,CAAJ,CAAY,CAAZ,IAAiB1B,IAAI,CAAC2B,KAAD,CAAJ,CAAY,CAAZ,CAA1F;AACA,eAAKnB,WAAL,CAAiBjB,cAAjB,CAAgCkB,MAAhC,CAAuCT,IAAI,CAAC2B,KAAD,CAAJ,CAAY,CAAZ,CAAvC,EAAuD3B,IAAI,CAAC0B,KAAD,CAAJ,CAAY,CAAZ,CAAvD,IAAyE1B,IAAI,CAAC0B,KAAD,CAAJ,CAAY,CAAZ,IAAiB1B,IAAI,CAAC2B,KAAD,CAAJ,CAAY,CAAZ,CAA1F;AACD;AACF;AACF;AACF;;AACDH,EAAAA,OAAO,CAACC,GAAR,CAAY,KAAKjB,WAAL,CAAiBjB,cAA7B;AACAiC,EAAAA,OAAO,CAACC,GAAR,CAAY,IAAZ;AACD;;AAED,SAASM,kBAAT,GAA8B;AAC5B,OAAKvB,WAAL,CAAiBd,aAAjB,GAAiC,EAAjC;;AACA,OAAK,IAAIa,IAAT,IAAiB,KAAKC,WAAL,CAAiBjB,cAAlC,EAAkD;AAChD,QAAIyC,OAAO,GAAG,CAACzB,IAAD,CAAd;;AACA,SAAK,IAAIP,IAAT,IAAiB,KAAKQ,WAAL,CAAiBjB,cAAjB,CAAgCgB,IAAhC,CAAjB,EAAwD;AACtD,UAAIP,IAAI,CAAC,CAAD,CAAJ,IAAW,KAAKQ,WAAL,CAAiBZ,eAAhC,EAAiD;AAC/CoC,QAAAA,OAAO,CAACpB,IAAR,CAAaZ,IAAI,CAAC,CAAD,CAAjB;AACD;AACF;;AACD,QAAIgC,OAAO,CAACC,MAAR,IAAkB,KAAKzB,WAAL,CAAiBX,cAAvC,EAAuD;AACrDmC,MAAAA,OAAO,CAACE,IAAR;AACAF,MAAAA,OAAO,GAAGG,IAAI,CAACC,SAAL,CAAeJ,OAAf,CAAV;;AACA,UAAI,CAAE,KAAKxB,WAAL,CAAiBd,aAAjB,CAA+BoC,QAA/B,CAAwCE,OAAxC,CAAN,EAAwD;AACtD,aAAKxB,WAAL,CAAiBd,aAAjB,CAA+BkB,IAA/B,CAAoCoB,OAApC;AACD;AACF;AACF;AACF;;AAED,SAASK,SAAT,GAAqB;AACnB,OAAK,IAAI9B,IAAT,IAAiB,KAAKE,MAAtB,EAA8B;AAC5BF,IAAAA,IAAI,CAAC+B,UAAL,CAAgB;AACdC,MAAAA,MAAM,EAAE,KAAKC;AADC,KAAhB;AAGAjC,IAAAA,IAAI,CAACkC,KAAL,GAAalC,IAAI,CAACG,EAAlB;AACD;;AACD,OAAK,IAAIsB,OAAT,IAAoB,KAAKxB,WAAL,CAAiBd,aAArC,EAAoD;AAClDsC,IAAAA,OAAO,GAAGG,IAAI,CAACO,KAAL,CAAWV,OAAX,CAAV;;AACA,SAAK,IAAItB,EAAT,IAAesB,OAAf,EAAwB;AAEtB,WAAK,IAAIzB,IAAT,IAAiB,KAAKoC,UAAL,CAAgBjC,EAAhB,CAAjB,EAAsC;AACpCH,QAAAA,IAAI,CAACkC,KAAL,IAAc,GAAd;AACAlC,QAAAA,IAAI,CAAC+B,UAAL,CAAgB;AACdC,UAAAA,MAAM,EAAE;AADM,SAAhB;AAGD;AACF;AACF;;AACD,OAAKK,IAAL;AACD;;AAED,eAAe,SAASC,MAAT,CAAgBC,QAAhB,EAA0B;AACvCA,EAAAA,QAAQ,CAAC,IAAD,EAAO,YAAP,EAAqB,CAACC,QAAD,EAAWC,IAAX,KAAoB;AAC/C,UAAMjD,IAAI,GAAGgD,QAAQ,CAAC,GAAGC,IAAJ,CAArB;AACA,UAAM,GAAIC,MAAM,GAAG,EAAb,IAAoBD,IAA1B;AACAjD,IAAAA,IAAI,CAACS,WAAL,GAAmBoB,MAAM,CAACsB,MAAP,CAAc,EAAd,EAAkB7D,QAAlB,EAA4B4D,MAAM,CAACzC,WAAP,IAAsB,EAAlD,CAAnB;AACA,WAAOT,IAAP;AACD,GALO,CAAR;AAMA+C,EAAAA,QAAQ,CAAC7D,IAAD,EAAO,MAAP,EAAe,UAAU8D,QAAV,EAAoBC,IAApB,EAA0B;AAC/CD,IAAAA,QAAQ,CAACI,KAAT,CAAe,IAAf,EAAqBH,IAArB;;AACA,QAAI,KAAKxC,WAAL,CAAiBlB,MAArB,EAA6B;AAC3BgC,MAAAA,mBAAmB,CAAC6B,KAApB,CAA0B,IAA1B;;AACA,UAAI,KAAK3C,WAAL,CAAiBhB,aAArB,EAAoC;AAClC,aAAKgB,WAAL,CAAiBf,WAAjB,GAA+B,IAA/B;AACD;AACF;AACF,GARO,CAAR;AASAqD,EAAAA,QAAQ,CAAC7D,IAAD,EAAO,MAAP,EAAe,UAAU8D,QAAV,EAAoBC,IAApB,EAA0B;AAC/CD,IAAAA,QAAQ,CAACI,KAAT,CAAe,IAAf,EAAqBH,IAArB;;AACA,QAAI,KAAKxC,WAAL,CAAiBhB,aAArB,EAAoC;AAClC,UAAI,KAAKgB,WAAL,CAAiBf,WAArB,EAAkC;AAChC,aAAKe,WAAL,CAAiBf,WAAjB,GAA+B,KAA/B,CADgC,CAEhC;AACA;AACD;AACF;AACF,GATO,CAAR;AAUD","sourcesContent":["import { Tree, utils } from 'phylocanvas';\n\nconst { getPixelRatio } = utils.canvas;\n\nconst DEFAULTS = {\n  active: true,\n  pairwiseMatrix: {},\n  clusterActive: true,\n  clusterDraw: true,\n  clusterMatrix: [],\n  clusterMaxDistance: 20,\n  clusterDistance: 3,\n  clusterSamples: 3,\n};\n\n/*\nfunction walkMatrix(tree, start, node, walked, distance, max) {\n  walked.push(node)\n\n  if (distance >= max) {\n    return\n  }\n  if (node !== start && node.leaf === true) {\n    tree.pairwiseOps.pairwiseMatrix[start.id].push([node.id, distance])\n  }\n  for (let child of node.children) {\n    if (! walked.includes(child)) {\n      let newDistance = distance + child.branchLength\n      newDistance = parseFloat(newDistance.toFixed(10))\n      walkMatrix(tree, start, child, walked, newDistance, max)\n    }\n  }\n  if (node.parent && ! walked.includes(node.parent)) {\n    let newDistance = distance + node.branchLength\n    newDistance = parseFloat(newDistance.toFixed(10))\n    walkMatrix(tree, start, node.parent, walked, newDistance, max)\n  }\n}\n\nfunction buildPairwiseMatrix() {\n  for (let leaf of this.leaves) {\n    this.pairwiseOps.pairwiseMatrix[leaf.id] = []\n    walkMatrix(this, leaf, leaf, [], 0, this.pairwiseOps.clusterMaxDistance)\n  }\n  console.log(this.pairwiseOps.pairwiseMatrix)\n}\n*/\n\nfunction walkMatrix(tree, node, path, distance) {\n  let newDistance = Array.from(distance)\n  let newPath = Array.from(path)\n  if (node.leaf === true) {\n    tree.pairwiseOps.pairwiseMatrix.leaves[node.id] = {}\n  }\n  if (node.parent !== null) {\n    newDistance.push(node.branchLength)\n  }\n  if (node.leaf === false) {\n    tree.pairwiseOps.pairwiseMatrix.internalNodes[node.id] = []\n    newPath.push(node.id)\n    for (let child of node.children) {\n      walkMatrix(tree, child, newPath, newDistance)\n    }\n  } else {\n    for (let i in newPath) {\n      tree.pairwiseOps.pairwiseMatrix.internalNodes[newPath[i]].push([node.id, newDistance.slice(i).reduce((previousValue, currentValue) => previousValue + currentValue)])\n    }\n  }  \n}\n\nfunction buildPairwiseMatrix() {\n  this.pairwiseOps.pairwiseMatrix = {\"internalNodes\": {}, \"leaves\": {}}\n  walkMatrix(this, this.root, [], [])\n  console.log(\"internal nodes\", this.pairwiseOps.pairwiseMatrix.internalNodes)\n  for (let node in this.pairwiseOps.pairwiseMatrix.internalNodes) {\n    node = this.pairwiseOps.pairwiseMatrix.internalNodes[node]\n    //console.log(node)\n    for (let leaf1 in node) {\n      for (let leaf2 in node.slice(leaf1 + 1)) {\n        if (! Object.keys(this.pairwiseOps.pairwiseMatrix.leaves[node[leaf1][0]]).includes(node[leaf2][0])) {\n          this.pairwiseOps.pairwiseMatrix.leaves[node[leaf1][0]][node[leaf2][0]] = node[leaf1][1] + node[leaf2][1]\n          this.pairwiseOps.pairwiseMatrix.leaves[node[leaf2][0]][node[leaf1][0]] = node[leaf1][1] + node[leaf2][1]\n        } else if (this.pairwiseOps.pairwiseMatrix.leaves[node[leaf1][0]][node[leaf2][0]] > node[leaf1][1] + node[leaf2][1]) {\n          this.pairwiseOps.pairwiseMatrix.leaves[node[leaf1][0]][node[leaf2][0]] = node[leaf1][1] + node[leaf2][1]\n          this.pairwiseOps.pairwiseMatrix.leaves[node[leaf2][0]][node[leaf1][0]] = node[leaf1][1] + node[leaf2][1]\n        }\n      }\n    }\n  }\n  console.log(this.pairwiseOps.pairwiseMatrix)\n  console.log(this)\n}\n\nfunction buildClusterMatrix() {\n  this.pairwiseOps.clusterMatrix = []\n  for (let leaf in this.pairwiseOps.pairwiseMatrix) {\n    let cluster = [leaf]\n    for (let node of this.pairwiseOps.pairwiseMatrix[leaf]) {\n      if (node[1] <= this.pairwiseOps.clusterDistance) {\n        cluster.push(node[0])\n      }\n    }\n    if (cluster.length >= this.pairwiseOps.clusterSamples) {\n      cluster.sort()\n      cluster = JSON.stringify(cluster)\n      if (! this.pairwiseOps.clusterMatrix.includes(cluster)) {\n        this.pairwiseOps.clusterMatrix.push(cluster)\n      }\n    }\n  }\n}\n\nfunction colorNode() {\n  for (let leaf of this.leaves) {\n    leaf.setDisplay({\n      colour: this.branchColour,\n    })\n    leaf.label = leaf.id\n  }\n  for (let cluster of this.pairwiseOps.clusterMatrix) {\n    cluster = JSON.parse(cluster)\n    for (let id of cluster) {\n      \n      for (let leaf of this.findLeaves(id)) {\n        leaf.label += \"+\"\n        leaf.setDisplay({\n          colour: 'red',\n        })\n      }\n    }\n  }\n  this.draw()\n}\n\nexport default function plugin(decorate) {\n  decorate(this, 'createTree', (delegate, args) => {\n    const tree = delegate(...args);\n    const [ , config = {} ] = args;\n    tree.pairwiseOps = Object.assign({}, DEFAULTS, config.pairwiseOps || {});\n    return tree;\n  });\n  decorate(Tree, 'load', function (delegate, args) {\n    delegate.apply(this, args);\n    if (this.pairwiseOps.active) {\n      buildPairwiseMatrix.apply(this);\n      if (this.pairwiseOps.clusterActive) {\n        this.pairwiseOps.clusterDraw = true;\n      }\n    }   \n  });\n  decorate(Tree, 'draw', function (delegate, args) {\n    delegate.apply(this, args);\n    if (this.pairwiseOps.clusterActive) {\n      if (this.pairwiseOps.clusterDraw) {\n        this.pairwiseOps.clusterDraw = false;\n        //buildClusterMatrix.apply(this);\n        //colorNode.apply(this)\n      }\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}